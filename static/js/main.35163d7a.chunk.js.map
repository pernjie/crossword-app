{"version":3,"sources":["Landing.js","icon.png","back.png","crossword_src/context.js","crossword_src/Cell.js","crossword_src/Clue.js","crossword_src/DirectionClues.js","crossword_src/util.js","crossword_src/Crossword.js","crossword_src/index.js","CustomPopup.js","Confetti.js","Puzzle.js","App.js","index.js"],"names":["CardComponent","to","this","props","id","className","class","src","alt","date","name","Component","App","document","title","href","CrosswordContext","React","createContext","focused","selectedDirection","selectedNumber","CrosswordSizeContext","cellSize","cellPadding","cellInner","cellHalf","fontSize","Cell","cellData","onClick","focus","highlight","useContext","ThemeContext","cellBackground","cellBorder","textColor","numberColor","focusBackground","highlightBackground","handleClick","useCallback","event","preventDefault","row","col","guess","number","x","y","style","cursor","width","height","fill","stroke","strokeWidth","textAnchor","dominantBaseline","defaultProps","ClueWrapper","styled","div","attrs","correct","Clue","direction","children","onClueSelected","DirectionClues","clues","toUpperCase","map","clue","undefined","directionInfo","across","primary","orthogonal","down","bothDirections","Object","keys","isAcross","otherDirection","calculateExtents","data","dir","primaryMax","orthogonalMax","entries","forEach","info","answer","length","emptyCellData","used","locked","fillClues","gridData","rowStart","colStart","i","push","sort","byNumber","createGridData","acrossMax","downMax","size","Math","max","values","Array","r","c","createEmptyGrid","a","b","Number","parseInt","loadGuesses","storageKey","localStorage","window","saveRaw","getItem","guesses","key","val","split","deserializeGuesses","JSON","parse","defaultTheme","columnBreakpoint","gridBackground","OuterWrapper","theme","GridWrapper","CluesWrapper","Crossword","forwardRef","ref","onCorrect","onLoadedCorrect","onCrosswordCorrect","onCellChange","useStorage","puzzleName","useState","setSize","setGridData","setClues","setFocused","focusedRow","setFocusedRow","focusedCol","setFocusedCol","currentDirection","setCurrentDirection","currentNumber","setCurrentNumber","bulkChange","setBulkChange","checkQueue","setCheckQueue","crosswordCorrect","setCrosswordCorrect","inputRef","useRef","contextTheme","getCellData","outOfBounds","setCellCharacter","char","cell","produce","draft","notifyCorrect","checkCorrectness","find","useEffect","every","clueInfo","current","moveTo","directionOverride","candidate","moveRelative","dRow","dCol","moveForward","moveBackward","handleSingleCharacter","handleInputKeyDown","ctrlKey","altKey","metaKey","other","handleInputChange","target","value","substring","loadedCorrect","correctAnswers","num","findCorrectAnswers","reduce","memo","memoInner","serializeGuesses","saveData","Date","now","setItem","stringify","saveGuesses","handleCellClick","handleInputClick","handleClueSelected","useImperativeHandle","reset","rowData","removeItem","fillAllAnswers","isCrosswordCorrect","context","finalTheme","cells","Provider","margin","padding","position","viewBox","type","onKeyDown","onChange","autoComplete","spellCheck","autoCorrect","top","left","textAlign","backgroundColor","caretColor","border","displayName","trigger","modal","nested","close","numberOfPieces","CorrectDisplay","isCorrect","color","Confetti","Puzzle","match","params","setIsCorrect","logo","CustomPopup","exact","path","component","Landing","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.35163d7a.chunk.js","sourcesContent":["import logo from './icon.png';\nimport './App.css';\nimport { Link } from 'react-router-dom';\nimport { Card, CardBody } from 'react-simple-card';\nimport { Component } from 'react';\n\nclass CardComponent extends Component {\n  render() {\n  return <Card>\n      <Link to={`puzzle/` + this.props.id} className=\"App-dead-link\">\n        <div id='box'>\n          <div class=\"item\"><img src={logo} className=\"App-logo\" alt=\"logo\" /></div>\n          <div class=\"item\"><CardBody><b>{this.props.date}</b><br/>{this.props.name}</CardBody></div>\n        </div>\n      </Link>\n    </Card>\n  }\n}\n\nfunction App() {\n  document.title = \"Strait Across\";\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h2>Crosswords</h2>\n        {/* New Singapore-based puzzles every week<br/> */}\n        <br/>\n\n        <CardComponent id=\"1\" date=\"1st October 2021\" name=\"Singapore Pools\"/>\n      </header>\n      <body><a href=\"mailto:perniciousperil@gmail.com\" className=\"App-link\">Leave feedback</a></body>\n    </div>\n  );\n}\n\nexport default App;\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAyZJREFUeJzt3UFqFFEYRtE/4lxIZ+oKHLkmt+U63IFztyGYJuAC4iCTEPQa2mdXqnPOsAuKj8Cli+rAmwEAAABehKu49mFm3p9rCGzs68z8fPphBfJ5Zj79tznwsnycmW9PP3yzwRDYDYFAEAgEgUAQCASBQBAIBIFAEAgEgUB4u+g+9zNzXHSvFQ5xzdbT1daLtCqQ48zcLLrXCvdxzdbT1daL5BELgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCCsOoLtMPs5nstWns03CASBQBAIBIFAEAgEgUBY9Zp3T+5n5rj1iEcOcc3W09XWZ3uNgRxn5mbrEY/U7xy2nm7J70cesSAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEgkAgCASCQCAIBIJAIAgEwms8gu0wi47nOgNbN+YbBIJAIAgEgkAgCASCQCC8xte8/D+3Ww945Hpmrv71JqsCuZ2Zm0X3WqHex+9p6968pL/r3cy8+9ebeMSCIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAirjmC7nocjr/ZgT1v35pKOk5uZdYFczYLz4M5kT1vZmEcsCAKBIBAIAoEgEAir3mLdz8xx0b1WuJ6Ht1W/s6etMzO35xryDH/benFWBXKcmZtF91rhbv78KndPW2f2tfXieMSCIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAgCgSAQCAKBIBAIAoEgEAirjmA7zMPZf3uwp60z+9p6cXyDQBAIBIFAEAgEgUAQCASBQBAIBIFAEAiE+leTLzPz41xDYGPftx4AAAAAAKf5BZdWPQDXagBWAAAAAElFTkSuQmCC\"","export default __webpack_public_path__ + \"static/media/back.80f03fd6.png\";","import React from 'react';\n\n// To pass focus/highlight/etc., it's cleaner to use a context.\nexport const CrosswordContext = React.createContext({\n  focused: false,\n  selectedDirection: null,\n  selectedNumber: null,\n\n  // correct answers?\n});\n\nexport const CrosswordSizeContext = React.createContext({\n  cellSize: 0,\n  cellPadding: 0,\n  cellInner: 0,\n  cellHalf: 0,\n  fontSize: 0,\n});\n","import React, { useCallback, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport { ThemeContext } from 'styled-components';\n\nimport { CrosswordSizeContext } from './context';\n\n// expected props: row, col, answer, crossword, cellSize\n\n/**\n * An individual-letter answer cell within the crossword grid.\n *\n * A `Cell` lives inside the SVG for a [`Crossword`](#crossword), and renders at\n * a location determined by the `row`, `col`, and `cellSize` properties from\n * `cellData` and `renderContext`.\n */\nexport default function Cell({ cellData, onClick, focus, highlight }) {\n  const { cellSize, cellPadding, cellInner, cellHalf, fontSize } = useContext(\n    CrosswordSizeContext\n  );\n  const {\n    // gridBackground,\n    cellBackground,\n    cellBorder,\n    textColor,\n    numberColor,\n    focusBackground,\n    highlightBackground,\n  } = useContext(ThemeContext);\n\n  const handleClick = useCallback(\n    (event) => {\n      event.preventDefault();\n      if (onClick) {\n        onClick(cellData);\n      }\n    },\n    [cellData, onClick]\n  );\n\n  const { row, col, guess, number } = cellData;\n\n  const x = col * cellSize;\n  const y = row * cellSize;\n\n  return (\n    <g\n      onClick={handleClick}\n      style={{ cursor: 'default', fontSize: `${fontSize}px` }}\n    >\n      <rect\n        x={x + cellPadding}\n        y={y + cellPadding}\n        width={cellInner}\n        height={cellInner}\n        fill={\n          focus\n            ? focusBackground\n            : highlight\n            ? highlightBackground\n            : cellBackground\n        }\n        stroke={cellBorder}\n        strokeWidth={cellSize / 50}\n      />\n      {number && (\n        <text\n          x={x + cellPadding * 4}\n          y={y + cellPadding * 4}\n          textAnchor=\"start\"\n          dominantBaseline=\"hanging\"\n          style={{ fontSize: '50%', fill: numberColor }}\n        >\n          {number}\n        </text>\n      )}\n      <text\n        x={x + cellHalf}\n        y={y + cellHalf + 1} // +1 for visual alignment?\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n        style={{ fill: textColor }}\n      >\n        {guess}\n      </text>\n    </g>\n  );\n}\n\nCell.propTypes = {\n  /** the data specific to this cell */\n  cellData: PropTypes.shape({\n    row: PropTypes.number.isRequired,\n    col: PropTypes.number.isRequired,\n    guess: PropTypes.string.isRequired,\n    number: PropTypes.string,\n  }).isRequired,\n\n  /** whether this cell has focus */\n  focus: PropTypes.bool,\n\n  /** whether this cell is highlighted */\n  highlight: PropTypes.bool,\n\n  /** handler called when the cell is clicked */\n  onClick: PropTypes.func,\n};\n\nCell.defaultProps = {\n  focus: false,\n  highlight: false,\n  onClick: null,\n};\n\n// export default Cell;\n","import React, { useCallback, useContext } from 'react';\nimport PropTypes from 'prop-types';\n\nimport styled, { ThemeContext } from 'styled-components';\n\nimport { CrosswordContext } from './context';\n\nconst ClueWrapper = styled.div.attrs((props) => ({\n  className: `clue${props.correct ? ' correct' : ''}`,\n}))`\n  cursor: default;\n  background-color: ${(props) =>\n    props.highlight ? props.highlightBackground : 'transparent'};\n  color: ${(props) =>\n    props.highlight ? 'black' : 'white'};\n`;\n\nexport default function Clue({\n  direction,\n  number,\n  children,\n  correct,\n  ...props\n}) {\n  const { highlightBackground } = useContext(ThemeContext);\n  const {\n    focused,\n    selectedDirection,\n    selectedNumber,\n    onClueSelected,\n  } = useContext(CrosswordContext);\n\n  const handleClick = useCallback(\n    (event) => {\n      event.preventDefault();\n      if (onClueSelected) {\n        onClueSelected(direction, number);\n      }\n    },\n    [direction, number, onClueSelected]\n  );\n\n  return (\n    <ClueWrapper\n      highlightBackground={highlightBackground}\n      highlight={\n        focused && direction === selectedDirection && number === selectedNumber\n      }\n      correct={correct}\n      {...props}\n      onClick={handleClick}\n      aria-label={`clue-${number}-${direction}`}\n    >\n      {number}: {children}\n    </ClueWrapper>\n  );\n}\n\nClue.propTypes = {\n  /** direction of the clue: \"across\" or \"down\"; passed back in onClick */\n  direction: PropTypes.string.isRequired,\n  /** number of the clue (the label shown); passed back in onClick */\n  number: PropTypes.string.isRequired,\n  /** clue text */\n  children: PropTypes.node,\n  /** whether the answer/guess is correct */\n  correct: PropTypes.bool,\n};\n\nClue.defaultProps = {\n  children: undefined,\n  correct: undefined,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\n// import styled from 'styled-components';\n\nimport Clue from './Clue';\n\nexport default function DirectionClues({ direction, clues }) {\n  return (\n    <div className=\"direction\">\n      {/* use something other than h3? */}\n      <h3 className=\"header\">{direction.toUpperCase()}</h3>\n      {clues.map(({ number, clue, correct }) => (\n        <Clue\n          key={number}\n          direction={direction}\n          number={number}\n          correct={correct}\n        >\n          {clue}\n        </Clue>\n      ))}\n    </div>\n  );\n}\n\nDirectionClues.propTypes = {\n  /** direction of this list of clues (\"across\" or \"down\") */\n  direction: PropTypes.string.isRequired,\n  /** clues for this List's direction */\n  clues: PropTypes.arrayOf(\n    PropTypes.shape({\n      /** number of the clue (the label shown) */\n      number: PropTypes.string.isRequired,\n      /** clue text */\n      clue: PropTypes.node.isRequired,\n      /** whether the answer/guess is correct */\n      correct: PropTypes.bool,\n    })\n  ).isRequired,\n};\n\nDirectionClues.defaultProps = {};\n","const directionInfo = {\n  across: {\n    primary: 'col',\n    orthogonal: 'row',\n  },\n  down: {\n    primary: 'row',\n    orthogonal: 'col',\n  },\n};\n\nexport const bothDirections = Object.keys(directionInfo);\n\nexport function isAcross(direction) {\n  return direction === 'across';\n}\n\nexport function otherDirection(direction) {\n  return isAcross(direction) ? 'down' : 'across';\n}\n\nexport function calculateExtents(data, direction) {\n  const dir = directionInfo[direction];\n  let primaryMax = 0;\n  let orthogonalMax = 0;\n\n  Object.entries(data[direction]).forEach(([i, info]) => {\n    const primary = info[dir.primary] + info.answer.length - 1;\n    if (primary > primaryMax) {\n      primaryMax = primary;\n    }\n\n    const orthogonal = info[dir.orthogonal];\n    if (orthogonal > orthogonalMax) {\n      orthogonalMax = orthogonal;\n    }\n  });\n\n  return {\n    [dir.primary]: primaryMax,\n    [dir.orthogonal]: orthogonalMax,\n  };\n}\n\nconst emptyCellData = {\n  used: false,\n  number: null,\n  answer: '',\n  guess: '',\n  locked: false,\n  // row: r,\n  // col: c,\n  across: null,\n  down: null,\n};\n\nexport function createEmptyGrid(size) {\n  const gridData = Array(size);\n  // Rather than [x][y] in column-major order, the cells are indexed as\n  // [row][col] in row-major order.\n  for (let r = 0; r < size; r++) {\n    gridData[r] = Array(size);\n    for (let c = 0; c < size; c++) {\n      gridData[r][c] = {\n        ...emptyCellData,\n        row: r,\n        col: c,\n      };\n    }\n  }\n\n  return gridData;\n}\n\nexport function fillClues(gridData, clues, data, direction) {\n  const dir = directionInfo[direction];\n\n  Object.entries(data[direction]).forEach(([number, info]) => {\n    const { row: rowStart, col: colStart, clue, answer } = info;\n    for (let i = 0; i < answer.length; i++) {\n      const row = rowStart + (dir.primary === 'row' ? i : 0);\n      const col = colStart + (dir.primary === 'col' ? i : 0);\n      const cellData = gridData[row][col];\n\n      // TODO?: check to ensure the answer is the same if it's already set?\n      cellData.used = true;\n      cellData.answer = answer[i];\n      cellData[direction] = number;\n\n      if (i === 0) {\n        // TODO?: check to ensure the number is the same if it's already set?\n        cellData.number = number;\n      }\n    }\n\n    clues[direction].push({ number, clue });\n  });\n\n  clues[direction].sort(byNumber);\n}\n\n// Given the \"nice format\" for a crossword, generate the usable data optimized\n// for rendering and our interactivity.\nexport function createGridData(data) {\n  const acrossMax = calculateExtents(data, 'across');\n  const downMax = calculateExtents(data, 'down');\n\n  const size =\n    Math.max(...Object.values(acrossMax), ...Object.values(downMax)) + 1;\n\n  const gridData = createEmptyGrid(size);\n\n  // Now fill with answers... and also collect the clues\n  const clues = {\n    across: [],\n    down: [],\n  };\n\n  fillClues(gridData, clues, data, 'across');\n  fillClues(gridData, clues, data, 'down');\n\n  return { size, gridData, clues };\n}\n\n// sort helper for clues...\nexport function byNumber(a, b) {\n  const aNum = Number.parseInt(a.number, 10);\n  const bNum = Number.parseInt(b.number, 10);\n\n  return aNum - bNum;\n}\n\nexport function clearGuesses(storageKey) {\n  if (!window.localStorage) {\n    return;\n  }\n\n  window.localStorage.removeItem(storageKey);\n}\n\nexport function saveGuesses(gridData, storageKey) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const guesses = serializeGuesses(gridData);\n\n  const saveData = {\n    date: Date.now(),\n    guesses,\n  };\n\n  localStorage.setItem(storageKey, JSON.stringify(saveData));\n}\n\nexport function serializeGuesses(gridData) {\n  const guesses = gridData.reduce((memo, row, r) => {\n    return row.reduce((memoInner, cellData, c) => {\n      const { guess } = cellData;\n      if (guess !== '') {\n        memoInner[`${r}_${c}`] = cellData.guess;\n      }\n      return memoInner;\n    }, memo);\n  }, {});\n\n  return guesses;\n}\n\nexport function loadGuesses(gridData, storageKey) {\n  const { localStorage } = window;\n  if (!localStorage) {\n    return;\n  }\n\n  const saveRaw = localStorage.getItem(storageKey);\n  if (!saveRaw) {\n    return;\n  }\n\n  const saveData = JSON.parse(saveRaw);\n\n  // TODO: check date for expiration?\n  deserializeGuesses(gridData, saveData.guesses);\n}\n\nexport function deserializeGuesses(gridData, guesses) {\n  Object.entries(guesses).forEach(([key, val]) => {\n    const [r, c] = key.split('_');\n    // ignore any out-of-bounds guesses!\n    if (r <= gridData.length - 1 && c <= gridData[0].length - 1) {\n      gridData[r][c].guess = val;\n    }\n  });\n}\n\nexport function findCorrectAnswers(data, gridData) {\n  const correctAnswers = [];\n\n  bothDirections.forEach((direction) => {\n    const across = isAcross(direction);\n    Object.entries(data[direction]).forEach(([num, info]) => {\n      const { row, col } = info;\n      let correct = true;\n      for (let i = 0; i < info.answer.length; i++) {\n        const r = across ? row : row + i;\n        const c = across ? col + i : col;\n        if (gridData[r][c].guess !== info.answer[i]) {\n          correct = false;\n          break;\n        }\n      }\n      if (correct) {\n        // same args as notifyCorrect: direction, number, answer\n        correctAnswers.push([direction, num, info.answer]);\n      }\n    });\n  });\n\n  return correctAnswers;\n}\n","import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport PropTypes from 'prop-types';\n\nimport produce from 'immer';\nimport styled, { ThemeContext, ThemeProvider } from 'styled-components';\n\nimport Cell from './Cell';\nimport DirectionClues from './DirectionClues';\n\nimport {\n  bothDirections,\n  createGridData,\n  isAcross,\n  otherDirection,\n  clearGuesses,\n  saveGuesses,\n  loadGuesses,\n  findCorrectAnswers,\n} from './util';\n\nimport { CrosswordContext, CrosswordSizeContext } from './context';\n\n// TODO: make this a component property!\nconst defaultStorageKey = 'guesses';\n\nconst defaultTheme = {\n  columnBreakpoint: '768px',\n  gridBackground: 'rgb(0,0,0)',\n  cellBackground: 'rgb(255,255,255)',\n  cellBorder: 'rgb(0,0,0)',\n  textColor: 'rgb(0,0,0)',\n  numberColor: 'rgba(0,0,0, 0.25)',\n  focusBackground: 'rgb(255,255,0)',\n  highlightBackground: 'rgb(255,255,204)',\n};\n\n// eslint-disable-next-line\nconst OuterWrapper = styled.div.attrs((props) => ({\n  className: `crossword${props.correct ? ' correct' : ''}`,\n}))`\n  margin: 0;\n  padding: 0;\n  border: 0;\n  /* position: relative; */\n  /* width: 40%; */\n  display: flex;\n  flex-direction: row;\n\n  @media (max-width: ${(props) => props.theme.columnBreakpoint}) {\n    flex-direction: column;\n  }\n`;\n\nconst GridWrapper = styled.div.attrs((props) => ({\n  className: 'grid',\n}))`\n  /* position: relative; */\n  min-width: 20rem;\n  max-width: 60rem; /* Should the size matter? */\n  width: auto;\n  flex: 2 1 50%;\n`;\n\nconst CluesWrapper = styled.div.attrs((props) => ({\n  className: 'clues',\n}))`\n  padding: 0 1em;\n  flex: 1 2 25%;\n\n  @media (max-width: ${(props) => props.theme.columnBreakpoint}) {\n    margin-top: 2em;\n  }\n\n  .direction {\n    margin-bottom: 2em;\n    /* padding: 0 1em;\n    flex: 1 1 20%; */\n\n    .header {\n      margin-top: 0;\n      margin-bottom: 0.5em;\n    }\n\n    div {\n      margin-top: 0.5em;\n    }\n  }\n`;\n\n/**\n * The primary, and default, export from the react-crossword library, Crossword\n * renders an answer grid and clues, and manages data and user interaction.\n */\nconst Crossword = React.forwardRef(\n  (\n    {\n      data,\n      onCorrect,\n      onLoadedCorrect,\n      onCrosswordCorrect,\n      onCellChange,\n      useStorage,\n      puzzleName,\n      theme,\n    },\n    ref\n  ) => {\n    const [size, setSize] = useState(null);\n    const [gridData, setGridData] = useState(null);\n    const [clues, setClues] = useState(null);\n    const [focused, setFocused] = useState(false);\n    const [focusedRow, setFocusedRow] = useState(0);\n    const [focusedCol, setFocusedCol] = useState(0);\n    const [currentDirection, setCurrentDirection] = useState('across');\n    const [currentNumber, setCurrentNumber] = useState('1');\n    const [bulkChange, setBulkChange] = useState(null);\n    const [checkQueue, setCheckQueue] = useState([]);\n    const [crosswordCorrect, setCrosswordCorrect] = useState(false);\n\n    const inputRef = useRef();\n\n    const contextTheme = useContext(ThemeContext);\n\n    const getCellData = useCallback(\n      (row, col) => {\n        if (row >= 0 && row < size && col >= 0 && col < size) {\n          return gridData[row][col];\n        }\n\n        // fake cellData to represent \"out of bounds\"\n        return { row, col, used: false, outOfBounds: true };\n      },\n      [size, gridData]\n    );\n\n    const setCellCharacter = useCallback(\n      (row, col, char) => {\n        const cell = getCellData(row, col);\n\n        if (!cell.used) {\n          return;\n        }\n\n        // If the character is already the cell's guess, there's nothing to do.\n        if (cell.guess === char) {\n          return;\n        }\n\n        // update the gridData with the guess\n        setGridData(\n          produce((draft) => {\n            draft[row][col].guess = char;\n          })\n        );\n\n        // push the row/col for checking!\n        setCheckQueue(\n          produce((draft) => {\n            draft.push({ row, col });\n          })\n        );\n\n        if (onCellChange) {\n          onCellChange(row, col, char);\n        }\n      },\n      [getCellData, onCellChange]\n    );\n\n    const notifyCorrect = useCallback(\n      (direction, number, answer) => {\n        if (onCorrect) {\n          // We *used* to need a timeout workaround to ensure this happened\n          // *after* the state had updated and the DOM rendered.... do we still?\n          onCorrect(direction, number, answer);\n\n          // For future reference, the call looked like:\n          //\n          // setTimeout(() => {\n          //   window.requestAnimationFrame(() => {\n          //     onCorrect(direction, number, answer);\n          //   });\n          // });\n        }\n      },\n      [onCorrect]\n    );\n\n    const checkCorrectness = useCallback(\n      (row, col) => {\n        const cell = getCellData(row, col);\n\n        // check all the cells for both across and down answers that use this\n        // cell\n        bothDirections.forEach((direction) => {\n          const across = isAcross(direction);\n          const number = cell[direction];\n          if (!number) {\n            return;\n          }\n\n          const info = data[direction][number];\n\n          // We start by looking at the current cell... if it's not correct, we\n          // don't need to check anything else!\n          let correct = cell.guess === cell.answer;\n\n          if (correct) {\n            // We *could* compare cell.guess against cell.answer for all the\n            // cells, but info.answer is a simple string and gets us the length\n            // as well (and we only have to calulate row/col math once).\n            for (let i = 0; i < info.answer.length; i++) {\n              const checkCell = getCellData(\n                info.row + (across ? 0 : i),\n                info.col + (across ? i : 0)\n              );\n\n              if (checkCell.guess !== info.answer[i]) {\n                correct = false;\n                break;\n              }\n            }\n          }\n\n          // update the clue state\n          setClues(\n            produce((draft) => {\n              const clueInfo = draft[direction].find(\n                (i) => i.number === number\n              );\n              clueInfo.correct = correct;\n            })\n          );\n\n          if (correct) {\n            notifyCorrect(direction, number, info.answer);\n          }\n        });\n      },\n      [getCellData]\n    );\n\n    // Any time the checkQueue changes, call checkCorrectness!\n    useEffect(() => {\n      if (checkQueue.length === 0) {\n        return;\n      }\n\n      checkQueue.forEach(({ row, col }) => checkCorrectness(row, col));\n      setCheckQueue([]);\n    }, [checkQueue, checkCorrectness]);\n\n    // Any time the clues change, determine if they are all correct or not.\n    useEffect(() => {\n      setCrosswordCorrect(\n        clues &&\n          bothDirections.every((direction) =>\n            clues[direction].every((clueInfo) => clueInfo.correct)\n          )\n      );\n    }, [clues]);\n\n    // Let the consumer know everything's correct (or not) if they've asked to\n    // be informed.\n    useEffect(() => {\n      if (onCrosswordCorrect) {\n        onCrosswordCorrect(crosswordCorrect);\n      }\n    }, [crosswordCorrect, onCrosswordCorrect]);\n\n    // focus and movement\n    const focus = useCallback(() => {\n      if (inputRef.current) {\n        inputRef.current.focus();\n        setFocused(true);\n      }\n    }, []);\n\n    const moveTo = useCallback(\n      (row, col, directionOverride) => {\n        let direction = directionOverride ?? currentDirection;\n        const candidate = getCellData(row, col);\n\n        if (!candidate.used) {\n          return false;\n        }\n\n        if (!candidate[direction]) {\n          direction = otherDirection(direction);\n        }\n\n        setFocusedRow(row);\n        setFocusedCol(col);\n        setCurrentDirection(direction);\n        setCurrentNumber(candidate[direction]);\n\n        return candidate;\n      },\n      [getCellData]\n    );\n\n    const moveRelative = useCallback(\n      (dRow, dCol) => {\n        // We expect *only* one of dRow or dCol to have a non-zero value, and\n        // that's the direction we will \"prefer\".  If *both* are set (or zero),\n        // we don't change the direction.\n        let direction;\n        if (dRow !== 0 && dCol === 0) {\n          direction = 'down';\n        } else if (dRow === 0 && dCol !== 0) {\n          direction = 'across';\n        }\n\n        const cell = moveTo(focusedRow + dRow, focusedCol + dCol, direction);\n\n        return cell;\n      },\n      [focusedRow, focusedCol, moveTo]\n    );\n\n    const moveForward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : 1, across ? 1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    const moveBackward = useCallback(() => {\n      const across = isAcross(currentDirection);\n      moveRelative(across ? 0 : -1, across ? -1 : 0);\n    }, [currentDirection, moveRelative]);\n\n    // keyboard handling\n    const handleSingleCharacter = useCallback(\n      (char) => {\n        setCellCharacter(focusedRow, focusedCol, char.toUpperCase());\n        moveForward();\n      },\n      [focusedRow, focusedCol, setCellCharacter, moveForward]\n    );\n\n    // We use the keydown event for control/arrow keys, but not for textual\n    // input, because it's hard to suss out when a key is \"regular\" or not.\n    const handleInputKeyDown = useCallback(\n      (event) => {\n        // if ctrl, alt, or meta are down, ignore the event (let it bubble)\n        if (event.ctrlKey || event.altKey || event.metaKey) {\n          return;\n        }\n\n        let preventDefault = true;\n        const { key } = event;\n        // console.log('CROSSWORD KEYDOWN', event.key);\n\n        // FUTURE: should we \"jump\" over black space?  That might help some for\n        // keyboard users.\n        switch (key) {\n          case 'ArrowUp':\n            moveRelative(-1, 0);\n            break;\n\n          case 'ArrowDown':\n            moveRelative(1, 0);\n            break;\n\n          case 'ArrowLeft':\n            moveRelative(0, -1);\n            break;\n\n          case 'ArrowRight':\n            moveRelative(0, 1);\n            break;\n\n          case ' ': // treat space like tab?\n          case 'Tab': {\n            const other = otherDirection(currentDirection);\n            const cellData = getCellData(focusedRow, focusedCol);\n            if (cellData[other]) {\n              setCurrentDirection(other);\n              setCurrentNumber(cellData[other]);\n            }\n            break;\n          }\n\n          // Backspace: delete the current cell, and move to the previous cell\n          // Delete:    delete the current cell, but don't move\n          case 'Backspace':\n          case 'Delete': {\n            setCellCharacter(focusedRow, focusedCol, '');\n            if (key === 'Backspace') {\n              moveBackward();\n            }\n            break;\n          }\n\n          case 'Home':\n          case 'End': {\n            // move to beginning/end of this entry?\n            const info = data[currentDirection][currentNumber];\n            const {\n              answer: { length },\n            } = info;\n            let { row, col } = info;\n            if (key === 'End') {\n              const across = isAcross(currentDirection);\n              if (across) {\n                col += length - 1;\n              } else {\n                row += length - 1;\n              }\n            }\n\n            moveTo(row, col);\n            break;\n          }\n\n          default:\n            // It would be nice to handle \"regular\" characters with onInput, but\n            // that is still experimental, so we can't count on it.  Instead, we\n            // assume that only \"length 1\" values are regular.\n            if (key.length !== 1) {\n              preventDefault = false;\n              break;\n            }\n\n            handleSingleCharacter(key);\n            break;\n        }\n\n        if (preventDefault) {\n          event.preventDefault();\n        }\n      },\n      [\n        data,\n        focusedRow,\n        focusedCol,\n        currentDirection,\n        currentNumber,\n        getCellData,\n        setCellCharacter,\n        moveRelative,\n      ]\n    );\n\n    const handleInputChange = useCallback((event) => {\n      event.preventDefault();\n      setBulkChange(event.target.value);\n    }, []);\n\n    useEffect(() => {\n      if (!bulkChange) {\n        return;\n      }\n\n      // handle bulkChange by updating a character at a time (this lets us\n      // leverage the existing character-entry logic).\n      handleSingleCharacter(bulkChange[0]);\n      setBulkChange(bulkChange.length === 1 ? null : bulkChange.substring(1));\n    }, [bulkChange, handleSingleCharacter]);\n\n    // When the data changes, recalculate the gridData, size, etc.\n    useEffect(() => {\n      // eslint-disable-next-line no-shadow\n      const { size, gridData, clues } = createGridData(data);\n\n      let loadedCorrect;\n      if (useStorage) {\n        // loadGuesses(gridData, defaultStorageKey);\n        loadGuesses(gridData, puzzleName);\n        loadedCorrect = findCorrectAnswers(data, gridData);\n\n        loadedCorrect.forEach(([direction, num]) => {\n          const clueInfo = clues[direction].find((i) => i.number === num);\n          clueInfo.correct = true;\n        });\n      }\n\n      setSize(size);\n      setGridData(gridData);\n      setClues(clues);\n\n      // Should we start with 1-across highlighted/focused?\n\n      // TODO: track input-field focus so we don't draw highlight when we're not\n      // really focused, *and* use first actual clue (whether across or down?)\n      setFocusedRow(0);\n      setFocusedCol(0);\n      setCurrentDirection('across');\n      setCurrentNumber('1');\n\n      setBulkChange(null);\n\n      // trigger any \"loaded correct\" guesses...\n      if (loadedCorrect && loadedCorrect.length > 0 && onLoadedCorrect) {\n        onLoadedCorrect(loadedCorrect);\n      }\n    }, [data, onLoadedCorrect, useStorage]);\n\n    useEffect(() => {\n      if (gridData === null || !useStorage) {\n        return;\n      }\n\n      saveGuesses(gridData, puzzleName);\n    }, [gridData, useStorage]);\n\n    const handleCellClick = useCallback(\n      (cellData) => {\n        const { row, col } = cellData;\n        const other = otherDirection(currentDirection);\n\n        // should this use moveTo?\n        setFocusedRow(row);\n        setFocusedCol(col);\n\n        let direction = currentDirection;\n\n        // We switch to the \"other\" direction if (a) the current direction isn't\n        // available in the clicked cell, or (b) we're already focused and the\n        // clicked cell is the focused cell, *and* the other direction is\n        // available.\n        if (\n          !cellData[currentDirection] ||\n          (focused &&\n            row === focusedRow &&\n            col === focusedCol &&\n            cellData[other])\n        ) {\n          setCurrentDirection(other);\n          direction = other;\n        }\n\n        setCurrentNumber(cellData[direction]);\n\n        focus();\n      },\n      [focused, focusedRow, focusedCol, currentDirection, focus]\n    );\n\n    const handleInputClick = useCallback(\n      (event) => {\n        // *don't* event.preventDefault(), because we want the input to actually\n        // take focus\n\n        // Like general cell-clicks, cliking on the input can change direction.\n        // Unlike cell clicks, we *know* we're clicking on the already-focused\n        // cell!\n        const other = otherDirection(currentDirection);\n        const cellData = getCellData(focusedRow, focusedCol);\n\n        let direction = currentDirection;\n\n        if (focused && cellData[other]) {\n          setCurrentDirection(other);\n          direction = other;\n        }\n\n        setCurrentNumber(cellData[direction]);\n        focus();\n      },\n      [currentDirection, focusedRow, focusedCol, getCellData, focus]\n    );\n\n    const handleClueSelected = useCallback(\n      (direction, number) => {\n        const info = data[direction][number];\n        // TODO: sanity-check info?\n        moveTo(info.row, info.col, direction);\n        focus();\n      },\n      [data, moveTo, focus]\n    );\n\n    // expose some imperative methods\n    useImperativeHandle(\n      ref,\n      () => ({\n        /**\n         * Sets focus to the crossword component.\n         */\n        focus: () => {\n          focus();\n        },\n\n        /**\n         * Resets the entire crossword; clearing all answers in the grid and\n         * also any persisted data.\n         */\n        reset: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = '';\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft[direction].forEach((clueInfo) => {\n                  delete clueInfo.correct;\n                });\n              });\n            })\n          );\n\n          if (useStorage) {\n            clearGuesses(puzzleName);\n          }\n        },\n\n        /**\n         * Fills all the answers in the grid and calls the `onLoadedCorrect`\n         * callback with _**every**_ answer.\n         */\n        fillAllAnswers: () => {\n          setGridData(\n            produce((draft) => {\n              draft.forEach((rowData) => {\n                rowData.forEach((cellData) => {\n                  if (cellData.used) {\n                    cellData.guess = cellData.answer;\n                  }\n                });\n              });\n            })\n          );\n\n          setClues(\n            produce((draft) => {\n              bothDirections.forEach((direction) => {\n                draft[direction].forEach((clueInfo) => {\n                  clueInfo.correct = true;\n                });\n              });\n            })\n          );\n\n          // trigger onLoadedCorrect with every clue!\n          if (onLoadedCorrect) {\n            const loadedCorrect = [];\n            bothDirections.forEach((direction) => {\n              Object.entries(data[direction]).forEach(([number, info]) => {\n                loadedCorrect.push([direction, number, info.answer]);\n              });\n            });\n\n            onLoadedCorrect(loadedCorrect);\n          }\n        },\n\n        /**\n         * Returns whether the crossword is entirely correct or not.\n         *\n         * @since 2.2.0\n         */\n        isCrosswordCorrect: () => {\n          return crosswordCorrect;\n        },\n      }),\n      [data, onLoadedCorrect, useStorage, focus, crosswordCorrect]\n    );\n\n    // constants for rendering...\n\n    // We have several properties that we bundle together as context for the\n    // cells, rather than have them as independent properties.  (Or should they\n    // stay separate? Or be passed as \"spread\" values?)\n    const cellSize = 100 / size;\n    const cellPadding = 0.125;\n    const cellInner = cellSize - cellPadding * 2;\n    const cellHalf = cellSize / 2;\n    const fontSize = cellInner * 0.7;\n\n    const context = {\n      focused,\n      selectedDirection: currentDirection,\n      selectedNumber: currentNumber,\n      onClueSelected: handleClueSelected,\n    };\n\n    // The final theme is the merger of three values: the \"theme\" property\n    // passed to the component (which takes precedence), any values from\n    // ThemeContext, and finally the \"defaultTheme\" values fill in for any\n    // needed ones that are missing.  (We create this in standard last-one-wins\n    // order in Javascript, of course.)\n    const finalTheme = { ...defaultTheme, ...contextTheme, ...theme };\n\n    // REVIEW: do we want to recalc this all the time, or cache in state?\n    const cells = [];\n    if (gridData) {\n      gridData.forEach((rowData, row) => {\n        rowData.forEach((cellData, col) => {\n          if (!cellData.used) {\n            return;\n          }\n          cells.push(\n            <Cell\n              // eslint-disable-next-line react/no-array-index-key\n              key={`R${row}C${col}`}\n              cellData={cellData}\n              focus={focused && row === focusedRow && col === focusedCol}\n              highlight={\n                focused &&\n                currentNumber &&\n                cellData[currentDirection] === currentNumber\n              }\n              onClick={handleCellClick}\n            />\n          );\n        });\n      });\n    }\n\n    return (\n      <CrosswordContext.Provider value={context}>\n        <CrosswordSizeContext.Provider\n          value={{ cellSize, cellPadding, cellInner, cellHalf, fontSize }}\n        >\n          <ThemeProvider theme={finalTheme}>\n            <OuterWrapper correct={crosswordCorrect}>\n              <GridWrapper>\n                {/*\n                This div is hard-coded because we *need* a zero-padded,\n                relative-positioned element for aligning the <input> with the\n                cells in the <svg>.\n              */}\n                <div style={{ margin: 0, padding: 0, position: 'relative' }}>\n                  <svg viewBox=\"0 0 100 100\">\n                    <rect\n                      x={0}\n                      y={0}\n                      width={100}\n                      height={100}\n                      fill={finalTheme.gridBackground}\n                    />\n                    {cells}\n                  </svg>\n                  <input\n                    ref={inputRef}\n                    aria-label=\"crossword-input\"\n                    type=\"text\"\n                    onClick={handleInputClick}\n                    onKeyDown={handleInputKeyDown}\n                    onChange={handleInputChange}\n                    value=\"\"\n                    // onInput={this.handleInput}\n                    autoComplete=\"off\"\n                    spellCheck=\"false\"\n                    autoCorrect=\"off\"\n                    style={{\n                      position: 'absolute',\n                      // In order to ensure the top/left positioning makes sense,\n                      // there is an absolutely-positioned <div> with no\n                      // margin/padding that we *don't* expose to consumers.  This\n                      // keeps the math much more reliable.  (But we're still\n                      // seeing a slight vertical deviation towards the bottom of\n                      // the grid!  The \"* 0.995\" seems to help.)\n                      top: `calc(${focusedRow * cellSize * 0.995}% + 2px)`,\n                      left: `calc(${focusedCol * cellSize}% + 2px)`,\n                      width: `calc(${cellSize}% - 4px)`,\n                      height: `calc(${cellSize}% - 4px)`,\n                      fontSize: `${fontSize * 6}px`, // waaay too small...?\n                      textAlign: 'center',\n                      textAnchor: 'middle',\n                      backgroundColor: 'transparent',\n                      caretColor: 'transparent',\n                      margin: 0,\n                      padding: 0,\n                      border: 0,\n                      cursor: 'default',\n                    }}\n                  />\n                </div>\n              </GridWrapper>\n              {/* <CluesWrapper>\n                {clues &&\n                  bothDirections.map((direction) => (\n                    <DirectionClues\n                      key={direction}\n                      direction={direction}\n                      clues={clues[direction]}\n                    />\n                  ))}\n              </CluesWrapper> */}\n              <CluesWrapper>\n                <div id=\"scrollbox\">\n                {clues && (\n                  <DirectionClues\n                    key={'across'}\n                    direction={'across'}\n                    clues={clues['across']}\n                  />\n                )}\n                </div>\n              </CluesWrapper>\n              <CluesWrapper>\n              <div id=\"scrollbox\">\n                {clues && (\n                  <DirectionClues\n                    key={'down'}\n                    direction={'down'}\n                    clues={clues['down']}\n                  />\n                )}\n                </div>\n              </CluesWrapper>\n            </OuterWrapper>\n          </ThemeProvider>\n        </CrosswordSizeContext.Provider>\n      </CrosswordContext.Provider>\n    );\n  }\n);\n\nCrossword.displayName = 'Crossword';\n\nconst clueShape = PropTypes.shape({\n  clue: PropTypes.string.isRequired,\n  answer: PropTypes.string.isRequired,\n  row: PropTypes.number.isRequired,\n  col: PropTypes.number.isRequired,\n});\n\nCrossword.propTypes = {\n  /** clue/answer data; see <a href=\"#cluedata-format\">Clue/data format</a> for details. */\n  data: PropTypes.shape({\n    /** \"across\" clues and answers */\n    across: PropTypes.objectOf(clueShape),\n    /** \"down\" clues and answers */\n    down: PropTypes.objectOf(clueShape),\n  }).isRequired,\n\n  /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */\n  theme: PropTypes.shape({\n    /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */\n    columnBreakpoint: PropTypes.string,\n\n    /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */\n    gridBackground: PropTypes.string,\n    /**  background for an answer cell */\n    cellBackground: PropTypes.string,\n    /** border for an answer cell */\n    cellBorder: PropTypes.string,\n    /** color for answer text (entered by the player) */\n    textColor: PropTypes.string,\n    /** color for the across/down numbers in the grid */\n    numberColor: PropTypes.string,\n    /** background color for the cell with focus, the one that the player is typing into */\n    focusBackground: PropTypes.string,\n    /** background color for the cells in the answer the player is working on,\n     * helps indicate in which direction focus will be moving; also used as a\n     * background on the active clue  */\n    highlightBackground: PropTypes.string,\n  }),\n\n  /** whether to use browser storage to persist the player's work-in-progress */\n  useStorage: PropTypes.bool,\n  puzzleName: PropTypes.string,\n\n  /** callback function that fires when a player answers a clue correctly; called with `(direction, number, answer)` arguments, where `direction` is `'across'` or `'down'`, `number` is the clue number as text (like `'1'`), and `answer` is the answer itself */\n  onCorrect: PropTypes.func,\n  /** callback function that's called when a crossword is loaded, to batch up correct answers loaded from storage; passed an array of the same values that `onCorrect` would recieve */\n  onLoadedCorrect: PropTypes.func,\n  /** callback function that's called when the overall crossword is completely correct (or not) */\n  onCrosswordCorrect: PropTypes.func,\n\n  /**\n   *  callback function called when a cell changes (e.g. when the user types a\n   *  letter); called with `(row, col, char)` arguments, where the `row` and\n   *  `column` are the 0-based position of the cell, and `char` is the character\n   *  typed (already massaged into upper-case)\n   *\n   *  @since 2.1.0\n   */\n  onCellChange: PropTypes.func,\n};\n\nCrossword.defaultProps = {\n  theme: null,\n  useStorage: true,\n  // useStorage: false,\n  puzzleName: 'guesses',\n  onCorrect: null,\n  onLoadedCorrect: null,\n  onCrosswordCorrect: null,\n  onCellChange: null,\n};\n\nexport default Crossword;\n","// We re-export ThemeProvider from styled-components so that consumers don't\n// have to pull it in explicitly if we are the only reason.  (This also helps\n// with our style guide!)\nimport { ThemeProvider } from 'styled-components';\n\nimport Cell from './Cell';\nimport Clue from './Clue';\nimport DirectionClues from './DirectionClues';\nimport Crossword from './Crossword';\nimport { CrosswordContext, CrosswordSizeContext } from './context';\n\nexport {\n  Cell,\n  Clue,\n  DirectionClues,\n  CrosswordContext,\n  CrosswordSizeContext,\n  Crossword,\n  ThemeProvider,\n};\n\nexport default Crossword;\n","import React from 'react';\nimport Popup from 'reactjs-popup';\nimport './popup.css';\nimport 'reactjs-popup/dist/index.css';\n\n\nexport default () => (\n    <Popup\n      trigger={<font className=\"App-link\">Help</font>}\n      modal\n      nested\n    >\n      {close => (\n        <div className=\"modal\">\n          <div className=\"header\"> How to read clues </div>\n          <div className=\"content\">\n            {' '}\n            1) Answers will always follow the form of the clue (eg. singular/plural, past/present)<br/>\n            2) \"in short\" in a clue means that the answer is abbreviated (eg. tablespoon = tbsp)<br/>\n            3) \"say\" in a clue means as an example<br/>\n            4) A question mark at the end of a clue implies some wordplay is involved\n          </div>\n        </div>\n      )}\n    </Popup>\n  );\n  ","import React from 'react'\n// import useWindowSize from 'react-use/lib/useWindowSize'\nimport Confetti from 'react-confetti'\n\nexport default () => {\n//   const { width, height } = useWindowSize()\n  return (\n    <Confetti numberOfPieces={700}/>\n  )\n}\n","import logo from './back.png';\nimport Crossword, { ThemeProvider } from './crossword_src/index';\nimport data from './crossword_data';\nimport { Link } from \"react-router-dom\";\nimport React from 'react';\nimport CustomPopup from './CustomPopup';\nimport Confetti from './Confetti';\n\n\nfunction Puzzle(props) {\n  const {id} = props.match.params\n  const [isCorrect, setIsCorrect] = React.useState(false);\n  \n  document.title = data[id]['puzzleName'];\n\n  return (\n    <div className=\"App-left\">\n      <Link to={`/`} className=\"App-link\"><img src={logo} width=\"10\" height=\"10\"/>&nbsp;&nbsp;<span>Back</span>&nbsp;&nbsp;</Link>\n      <CustomPopup/>\n      <h2>{data[id]['puzzleName']} <CorrectDisplay isCorrect={isCorrect} /></h2>\n\n      <div>\n        <ThemeProvider\n          theme={{\n              // columnBreakpoint: '9999px',\n              gridBackground: '#282c34',\n              // cellBackground: '#ffe',\n              // cellBorder: '#fca',\n              textColor: '#222D43',\n              // numberColor: '#9f9',\n              focusBackground: '#FAD988',\n              highlightBackground: '#FFEAB5',\n          }}\n          >\n            <Crossword data={data[id]['data']} puzzleName={data[id]['puzzleName']} onCrosswordCorrect = {(isCrosswordCorrect) => {\n              setIsCorrect(isCrosswordCorrect);\n            }}/>\n          </ThemeProvider>\n        </div>\n    </div>\n  );\n}\n\nclass CorrectDisplay extends React.Component {\n  render() {\n    if (this.props.isCorrect) {\n      return (\n        <span style={{color:'#0BC175'}}><Confetti/> (Complete)</span>\n      );\n    } else {\n      return (\n        <span style={{color:'#FE6E61'}}> (Incomplete)</span>\n      )\n    }\n  }\n}\n\nexport default Puzzle;\n","import { Route, Switch } from 'react-router-dom';\nimport Landing from './Landing';\nimport Puzzle from './Puzzle';\n\nfunction App() {\n  return (\n    <Switch>\n      <Route exact path=\"/\" component={Landing} />\n      <Route path=\"/puzzle/:id\" component={Puzzle} />\n    </Switch>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { HashRouter } from 'react-router-dom';\nimport Analytics from 'react-router-ga';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <HashRouter>\n      <Analytics id=\"UA-206870903-1\">\n        <App />\n      </Analytics>\n    </HashRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}